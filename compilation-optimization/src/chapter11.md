# 后端编译与优化

- 从计算机程序出现的第一天起,对效率的追逐就是程序员天生的坚定信仰,这个过程犹如一场没有终点,永不停歇的F1方程式竞赛,程序员是车手,技术平台则是在赛道上飞驰的赛车

## 概述

- 如果我们把字节码看作是程序语言的一种中间表示形式,那编译器无论在何时,在何种状态下把Class文件转换成与本地基础设施(硬件指令集,操作系统)相关的二进制机器码,它都可以视为整个编译过程的后端

## 即时编译器

- 目前主流的两款商用Java虚拟机(HotSpot,OpenJ9)里,Java程序最初都是通过解释器(Interpreter)进行解释执行的,当虚拟机发现某个方法或代码块的运行特别频繁,就会把这些代码认定为"热点代码"(HotSpot
  Code),为了提高热点代码的执行效率,在运行时,虚拟机将会把这些代码编译成本地机器码,并以各种手段尽可能地进行代码优化,运行时完成这个任务的后端编译器被称为即时编译器

### 解释器与编译器

- 尽管并不是所有的Java虚拟机都采用解释器与编译器并存的运行架构,但目前主流的商用Java虚拟机,譬如HotSpot,OpenJ9等,内部都同时包含解释器与编译器

- 解释器与编译器两者各有优势
    - 当程序需要迅速启动和执行的时候,解释器可以首先发挥作用,省去编译的时间,立即运行
    - 当程序启动后,随着时间的推移,编译器逐渐发挥作用,把越来越多的代码编译成本地代码,这样可以减少解释器的中间损耗,获得更高执行效率
    - 当程序运行环境中内存资源限制较大,可以使用解释执行节约内存,反之可以使用编译执行来提升效率
    - 解释器还可以作为编译器激进优化时后备的逃生门(如果情况允许,HotSpot虚拟机中也会采用不进行激进优化的客户端编译器充当逃生门的角色)
        - 让编译器根据概率选择一些不能保证所有情况都正确,但大多数时候都能提升运行速度的优化手段
        - 当激进优化的假设不成立,如加载了新类以后,类型继承结构出现变化,出现罕见陷阱(Uncommon Trap)时可以通过逆优化(Deoptimization)退回到解释状态继续执行

- HotSpot虚拟机中内置了两个(或三个)即时编译器,其中两个编译器存在已久,分别称为客户端编译器和服务端编译器,也称为C1和C2编译器,其中C2也叫Opto编译器,第三个是在JDK10时才出现的,长期目标是代替C2的Graal编译器

- 在分层编译(Tiered Compilation)的工作模式出现以前,HotSpot虚拟机通常是采用解释器与其中一个编译器直接搭配的方式工作,程序使用哪个编译器,只取决于虚拟机运行的模式
    - HotSpot虚拟机会根据自身版本与宿主机器的硬件性能自动选择运行模式
    - 用户也可以使用-client或-server参数去强制指定虚拟机运行在客户端模式还是服务端模式

- 无论采用的编译器是客户端编译器还是服务端编译器,解释器与编译器搭配使用的方式在虚拟机中被称为混合模式(Mixed Mode)
    - 用户可以使用参数-Xint强制虚拟机运行解释模式(Interpreted Mode),全部代码使用解释方式执行
    - 也可以使用参数-Xcomp强制虚拟机运行于编译模式(Compiled Mode),这时候将优先采用编译方式执行程序,但是解释器仍然要在编译无法进行的情况下介入执行过程

- 通过-version命令输出显示三种运行模式

```
C:\Users\Admin>java -version
java version "1.8.0_301"
Java(TM) SE Runtime Environment (build 1.8.0_301-b09)
Java HotSpot(TM) 64-Bit Server VM (build 25.301-b09, mixed mode)

C:\Users\Admin>java -Xint -version
java version "1.8.0_301"
Java(TM) SE Runtime Environment (build 1.8.0_301-b09)
Java HotSpot(TM) 64-Bit Server VM (build 25.301-b09, interpreted mode)

C:\Users\Admin>java -Xcomp -version
java version "1.8.0_301"
Java(TM) SE Runtime Environment (build 1.8.0_301-b09)
Java HotSpot(TM) 64-Bit Server VM (build 25.301-b09, compiled mode)
```

- 分层编译在JDK7的服务端模式虚拟机中作为默认编译策略被开启,根据编译器编译,优化的规模与耗时,划分出不同的编译层次
    - 第0层:程序纯解释执行,并且解释器不开启性能监控功能(Profiling)
    - 第1层:使用客户端编译器将字节码编译为本地代码来运行,进行简单可靠的稳定优化,不开启性能监控功能
    - 第2层:仍然使用客户端编译器执行,仅开启方法及回边次数统计等有限的性能监控功能
    - 第3层:仍然使用客户端编译器执行,开启全部性能监控,除了第2层的统计信息外,还会收集如分支跳转,虚方法调用版本等全部的统计信息
    - 第4层:使用服务端编译器将字节码编译为本地代码,相比起客户端编译器,服务端编译器会启用更多编译耗时更长的优化,还会根据性能监控信息进行一些不可靠的激进优化
- 以上层次并不是固定不变的,根据不同的运行参数和版本,虚拟机可以调整分层的数量


- 实施分层编译后
    - 解释器,客户端编译器和服务端编译器就会同时工作
    - 热点代码都可能会被多次编译,用客户端编译器获取更高的编译速度,用服务端编译器来获取更好的编译质量,在解释执行的时候也无须额外承担收集性能监控信息的任务
    - 而在服务端编译器采用高复杂度的优化算法时,客户端编译器可先采用简单优化来为它争取更多的编译时间

### 编译对象与触发条件

- 在运行过程中会被即时编译器编译的目标是热点代码,热点代码主要有两类:一是被多次调用的方法,二是被多次执行的循环体

### 提前编译器

- 三种即时编译器相对于提前编译器的天然优势
    - 性能分析制导优化(Profile-Guided Optimization,PGO)
    - 激进预测性优化(Aggressive Speculative Optimization)
    - 链接时优化(Link-Time Optimization,LTO)

### 编译器优化技术

- 典型的优化技术
    - 方法内联
        - 去除方法调用的成本(如查找方法版本,建立栈帧等)
        - 为其他优化建立良好的基础
    - 冗余访问消除(Redundant Loads Elimination)
        - 可以把这项优化看作一种公共子表达式消除(Common Subexpression Elimination)
    - 复写传播(Copy Propagation)
    - 无用代码消除(Dead Code Elimination)
        - 无用代码可能是永远不会被执行的代码,也可能是完全没有意义的代码

```
static class B {
    int value;
    final int get() {
        return value;
    }
}

public void foo() {
    y = b.get();
    // ...do stuff...
    z = b.get();
    sum = y + z;
}

//内联
public void foo() {
    y = b.value;
    // ...do stuff...
    z = b.value;
    sum = y + z;
}

//冗余访问消除
public  void foo() {
    y = b.value;
    // ...do stuff...
    z = y;
    sum = y + z;
}

//复写传播
public  void foo() {
    y = b.value;
    // ...do stuff...
    y = y;
    sum = y + y;
}

//无用代码消除
public  void foo() {
    y = b.value;
    // ...do stuff...
    sum = y + y;
}

```

- 代表性的优化技术
    - 最重要的优化技术之一:方法内联
    - 最前沿的优化技术之一:逃逸分析
    - 语言无关的经典优化技术之一:公共子表达式消除
    - 语言相关的经典优化技术之一:数组边界检查消除

#### 方法内联

#### 逃逸分析

- 逃逸分析(Escape Analysis)是目前Java虚拟机中比较前沿的优化技术,它与类型继承关系分析一样,并不是直接优化代码的手段,而是为其他优化措施提供依据的分析技术

- 逃逸分析的基本原理
    - 分析对象动态作用域,当一个对象在方法里面被定义后,它可能被外部方法所引用,例如作为调用参数传递到其他方法中,这种称为方法逃逸
    - 甚至还有可能被外部线程访问到,譬如赋值给可以在其他线程中访问的实例变量,这种称为线程逃逸

- 如果能证明一个对象不会逃逸到方法或线程之外(换句话说是别的方法或线程无法通过任何途径访问到这个对象),或者逃逸程度比较低(只逃逸出方法而不会逃逸出线程),则可能为这个对象实例采取不同程度的优化
    - 栈上分配(Stack Allocations)
        - 栈上分配可以支持方法逃逸,但不能支持线程逃逸
    - 标量替换(Scalar Replacement)
        - 若一个数据已经无法再分解成更小的数据来表示了,Java虚拟机中的原始数据类型(int,long等数值类型及reference类型等)都不能再进一步分解了,那么这些数据就可以被称为标量
        - 如果一个数据可以继续分解,那它就被称为聚合量(Aggregate),Java中的对象就是典型的聚合量
        - 如果把一个Java对象拆散,根据程序访问的情况,将其用到的成员变量恢复为原始类型来访问,这个过程就称为标量替换
        - 假如逃逸分析能够证明一个对象不会被方法外部访问,并且这个对象可以被拆散,那么程序真正执行的时候将可能不去创建这个对象,而改为直接创建它的若干个被这个方法使用的成员变量来代替,将对象拆分后,除了可以让对象的成员变量在栈上(
          栈上存储的数据,很大机会被虚拟机分配至物理机器的高速寄存器中存储)分配和读写之外,还可以为后续进一步的优化手段创建条件
        - 标量替换可以视作栈上分配的一种特例,实现更简单(不用考虑整个对象完整结构的分配),但对逃逸程度的要求更高,它不允许对象逃逸出方法范围内
    - 同步消除(Synchronization Elimination)
        - 线程同步本身是一个相对耗时的过程,如果逃逸分析能够确定一个变量不会逃逸出线程,无法被其他线程访问,那么这个变量的读写肯定就不会有竞争,对这个变量实施的同步措施也就可以安全地消除掉

```
// 完全未优化的代码
public int test(int x) {
    int xx = x + 2;
    Point p = new Point(xx, 42);
    return p.getX();
}

// 步骤1：构造函数内联后的样子
public int test(int x) {
    int xx = x + 2;
    Point p = point_memory_alloc();   // 在堆中分配P对象的示意方法
    p.x = xx;                         // Point构造函数被内联后的样子
    p.y = 42
    return p.x;                       // Point::getX()被内联后的样子
}

// 步骤2：标量替换后的样子
public int test(int x) {
    int xx = x + 2;
    int px = xx;
    int py = 42
    return px;
}

// 步骤3：做无效代码消除后的样子
public int test(int x) {
    return x + 2;
}
```

#### 公共子表达式消除

- 如果一个表达式E之前已经被计算过了,并且从先前的计算到现在E中所有变量的值都没有发生变化,那么E的这次出现就称为公共子表达式,对于这种表达式,没有必要花时间再对它重新进行计算,只需要直接用前面计算过的表达式结果代替E
    - 如果这种优化仅限于程序基本块内,便可称为局部公共子表达式消除(Local Common Subexpression Elimination)
    - 如果这种优化的范围涵盖了多个基本块,那就称为全局公共子表达式消除(Global Common Subexpression Elimination)

```
int d = (c * b) * 12 + a + (a + b * c);

//优化后
int d = E * 12 + a + (a + E);
```

#### 数组边界检查消除

- 数组边界检查消除(Array Bounds Checking Elimination)是即时编译器中的一项语言相关的经典优化技术








