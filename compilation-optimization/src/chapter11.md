# 后端编译与优化

- 从计算机程序出现的第一天起,对效率的追逐就是程序员天生的坚定信仰,这个过程犹如一场没有终点、永不停歇的F1方程式竞赛,程序员是车手,技术平台则是在赛道上飞驰的赛车

## 概述

- 如果我们把字节码看作是程序语言的一种中间表示形式,那编译器无论在何时,在何种状态下把Class文件转换成与本地基础设施(硬件指令集,操作系统)相关的二进制机器码,它都可以视为整个编译过程的后端

## 即时编译器

- 目前主流的两款商用Java虚拟机(HotSpot,OpenJ9)里,Java程序最初都是通过解释器(Interpreter)进行解释执行的,当虚拟机发现某个方法或代码块的运行特别频繁,就会把这些代码认定为"热点代码"(HotSpot
  Code),为了提高热点代码的执行效率,在运行时,虚拟机将会把这些代码编译成本地机器码,并以各种手段尽可能地进行代码优化,运行时完成这个任务的后端编译器被称为即时编译器

### 解释器与编译器

- 尽管并不是所有的Java虚拟机都采用解释器与编译器并存的运行架构,但目前主流的商用Java虚拟机,譬如HotSpot,OpenJ9等,内部都同时包含解释器与编译器

- 解释器与编译器两者各有优势
    - 当程序需要迅速启动和执行的时候,解释器可以首先发挥作用,省去编译的时间,立即运行
    - 当程序启动后,随着时间的推移,编译器逐渐发挥作用,把越来越多的代码编译成本地代码,这样可以减少解释器的中间损耗,获得更高执行效率
    - 当程序运行环境中内存资源限制较大,可以使用解释执行节约内存,反之可以使用编译执行来提升效率
    - 解释器还可以作为编译器激进优化时后备的逃生门(如果情况允许,HotSpot虚拟机中也会采用不进行激进优化的客户端编译器充当逃生门的角色)
        - 让编译器根据概率选择一些不能保证所有情况都正确,但大多数时候都能提升运行速度的优化手段
        - 当激进优化的假设不成立,如加载了新类以后,类型继承结构出现变化,出现罕见陷阱(Uncommon Trap)时可以通过逆优化(Deoptimization)退回到解释状态继续执行

- HotSpot虚拟机中内置了两个(或三个)即时编译器,其中两个编译器存在已久,分别称为客户端编译器和服务端编译器,也称为C1和C2编译器,其中C2也叫Opto编译器,第三个是在JDK10时才出现的,长期目标是代替C2的Graal编译器

- 在分层编译(Tiered Compilation)的工作模式出现以前,HotSpot虚拟机通常是采用解释器与其中一个编译器直接搭配的方式工作,程序使用哪个编译器,只取决于虚拟机运行的模式
    - HotSpot虚拟机会根据自身版本与宿主机器的硬件性能自动选择运行模式
    - 用户也可以使用-client或-server参数去强制指定虚拟机运行在客户端模式还是服务端模式

- 无论采用的编译器是客户端编译器还是服务端编译器,解释器与编译器搭配使用的方式在虚拟机中被称为混合模式(Mixed Mode)
    - 用户可以使用参数-Xint强制虚拟机运行解释模式(Interpreted Mode),全部代码使用解释方式执行
    - 也可以使用参数-Xcomp强制虚拟机运行于编译模式(Compiled Mode),这时候将优先采用编译方式执行程序,但是解释器仍然要在编译无法进行的情况下介入执行过程

- 通过-version命令输出显示三种运行模式

```
C:\Users\Admin>java -version
java version "1.8.0_301"
Java(TM) SE Runtime Environment (build 1.8.0_301-b09)
Java HotSpot(TM) 64-Bit Server VM (build 25.301-b09, mixed mode)

C:\Users\Admin>java -Xint -version
java version "1.8.0_301"
Java(TM) SE Runtime Environment (build 1.8.0_301-b09)
Java HotSpot(TM) 64-Bit Server VM (build 25.301-b09, interpreted mode)

C:\Users\Admin>java -Xcomp -version
java version "1.8.0_301"
Java(TM) SE Runtime Environment (build 1.8.0_301-b09)
Java HotSpot(TM) 64-Bit Server VM (build 25.301-b09, compiled mode)
```