# 前端编译与优化

- 从计算机程序出现的第一天起,对效率的追逐就是程序员天生的坚定信仰,这个过程犹如一场没有终点,永不停歇的F1方程式竞赛,程序员是车手,技术平台则是在赛道上飞驰的赛车

## 概述

- 前端编译器:JDK的Javac,Eclipse JDT中的增量式编译器(ECJ)
- 即时编译器:HotSpot虚拟机的C1,C2编译器.Graal编译器
- 提前编译器:JDK的Jaotc,GNU Compiler for the Java(GCJ),Excelsior JET

- Java中即时编译器在运行期的优化过程,支撑了程序执行效率的不断提升;而前端编译器在编译期的优化过程,则是支撑着程序员的编码效率和语言使用者的幸福感的提高

## Javac编译器

- 分析源码是了解一项技术的实现内幕最彻底的手段,它本身就是一个由Java语言编写的程序,这为纯Java的程序员了解它的编译过程带来了很大的便利
- HotSpot虚拟机使用C++语言含少量C语言实现

### Javac的源码与调试

- Javac代码的总体结构来看,编译过程大致可以分为1个准备过程和3个处理过程
    - 准备过程:初始化插入式注解处理器
    - 解析与填充符号表过程
        - 词法,语法分析.将源代码的字符串流转变为标记集合,构造出抽象语法树
        - 填充符号表.产生符合地址和符合信息
    - 插入式注解处理器的注解处理过程
        - 分析与字节码生成过程
        - 标注检查.对语法的静态信息进行检查.
        - 数据流及控制流分析.对程序动态运行过程进行检查.
        - 解语法糖.将简化代码编写的语法糖还原为原有的形式.
        - 字节码生成.将前面各个步骤所生成的信息转化成字节码

### 解析与填充符号表

- 解析过程包括了经典程序编译原理中的词法分析和语法分析两个步骤
    - 词法,语法分析
        - 词法分析是将源代码的字符流转变为标记(Token)集合的过程.单个字符是程序编写时的最小元素.但标记才是编译时的最小元素.关键字,变量名,字面量,运算符都可以作为标记
        - 语法分析是根据标记序列构造抽象语法树的过程,抽象语法树(Abstract Syntax Tree,AST)是一种用来描述程序代码语法结构的树形表示方式,抽象语法树的每一个节点都代表着程序代码中的一个语法结构(Syntax
          Construct),例如包,类型,修饰符,运算符,接口,返回值甚至连代码注释等都可以是一种特定的语法结构
- 填充符号表
    - 符号表(Symbol Table)是由一组符号地址和符号信息构成的数据结构,符号表中所登记的信息在编译的不同阶段都要被用到

### 注解处理器

- 插入式注解处理器的标准API,可以提前至编译期对代码中的特定注解进行处理,从而影响到前端编译器的工作过程,例如Lombok

### 语义分析与字节码生成

- 语义分析的主要任务则是对结构上正确的源程序进行上下文相关性质的检查,譬如进行类型检查,控制流检查,数据流检查,等等
    - 经过语法分析之后,编译器获得了程序代码的抽象语法树表示,抽象语法树能够表示一个结构正确的源程序,但无法保证源程序的语义是符合逻辑的

- 语义分析过程可分为标注检查和数据及控制流分析两个步骤
    - 标注检查步骤要检查的内容包括诸如变量使用前是否已被声明,变量与赋值之间的数据类型是否能够匹配,等等
        - 在标注检查中,还会顺便进行一个称为常量折叠(Constant Folding)的代码优化,这是Javac编译器会对源代码做的极少量优化措施之一(代码优化几乎都在即时编译器中进行)
            - 例如int a = 1 + 2 会优化为int a = 3
    - 数据流分析和控制流分析是对程序上下文逻辑更进一步的验证
        - 它可以检查出诸如程序局部变量在使用前是否有赋值,方法的每条路径是否都有返回值,是否所有的受查异常都被正确处理了等问题

- 解语法糖

- 字节码生成是Javac编译过程的最后一个阶段
    - 字节码生成阶段不仅仅是把前面各个步骤所生成的信息(语法树,符号表)转化成字节码指令写到磁盘中,编译器还进行了少量的代码添加和转换工作

## Java语法糖的味道

- 几乎所有的编程语言都或多或少提供过一些语法糖来方便程序员的代码开发,这些语法糖虽然不会提供实质性的功能改进,但是它们或能提高效率,或能提升语法的严谨性,或能减少编码出错的机会

### 泛型

- 泛型的本质是参数化类型(Parameterized Type)或者参数化多态(Parametric Polymorphism)的应用
    - 即可以将操作的数据类型指定为方法签名中的一种特殊参数,这种参数类型能够用在类,接口和方法的创建中,分别构成泛型类,泛型接口和泛型方法
    - 泛型让程序员能够针对泛化的数据类型编写相同的算法,这极大地增强了编程语言的类型系统及抽象能力

- Java与C#的泛型
    - Java选择的泛型实现方式叫作类型擦除式泛型(Type Erasure Generics)
    - C#选择的泛型实现方式是具现化式泛型(Reified Generics),无须像Java里那样不厌其烦地拆箱和装箱

```java
//在Java中不合法
public class TypeErasureGenerics<E> {
    public void doSomething(Object item) {
        if (item instanceof E) {   // 不合法，无法对泛型进行实例判断

        }
        E newItem = new E();       // 不合法，无法使用泛型创建对象
        E[] itemArray = new E[10]; // 不合法，无法使用泛型创建数组
    }
}
```

- 类型擦除
    - 裸类型(Raw Type)的概念,裸类型应被视为所有该类型泛型化实例的共同父类型(Super Type)
    - com.weiliai.GenericTypes

### 自动装箱,拆箱与遍历循环

- 鉴于包装类的"=="运算在不遇到算术运算的情况下不会自动拆箱,以及它们equals()方法不处理数据转型的关系

- 业务代码
    - com.weiliai.AutoPackUnPack

### 条件编译

```
public static void main(String[] args) {
    if (true) {
        System.out.println("block 1");
    } else {
        System.out.println("block 2");
    }
}
优化后
public static void main(String[] args) {
    System.out.println("block 1");
}
```

```
public static void main(String[] args) {
    // 编译器将会提示“Unreachable code”
    while (false) {
        System.out.println("");
    }
}
//拒绝编译
```

