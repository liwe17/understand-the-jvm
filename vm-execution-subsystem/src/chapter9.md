# 类加载及执行子系统的案例与实战

- 代码编译的结果从本地机器码转变为字节码,是存储格式发展的一小步,却是编程语言发展的一大步

## 概述

- 在Class文件格式与执行引擎这部分里,用户的程序能直接参与的内容并不太多,Class文件以何种格式存储,类型何时加载,如何连接,以及虚拟机如何执行字节码指令等都是由虚拟机直接控制的行为,用户程序无法对其进行改变
- 能通过程序进行操作的,主要是字节码生成与类加载器这两部分的功能,但仅仅在如何处理这两点上,就已经出现了许多值得欣赏和借鉴的思路,这些思路后来成为许多常用功能和程序实现的基础

## 案例分析

### Tomcat:正统的类加载器架构

### OSGi:灵活的类加载器架构

### 字节码生成技术与动态代理的实现

- 业务代码
    - com.weiliai.chapter9.DynamicProxyTest

### Backport工具:Java的时光机器

## 实战:自己动手实现远程执行功能

### 目标

- 产品目标
    - 不依赖某个JDK版本才加入的特性(包括JVMTI),能在目前还被普遍使用的JDK中部署,只要是使用JDK 1.4以上的JDK都可以运行
    - 不改变原有服务端程序的部署,不依赖任何第三方类库
    - 不侵入原有程序,即无须改动原程序的任何代码.也不会对原有程序的运行带来任何影响
    - 考虑到BeanShell Script或JavaScript等脚本与Java对象交互起来不太方便,"临时代码"应该直接支持Java语言
    - "临时代码"应当具备足够的自由度,不需要依赖特定的类或实现特定的接口.这里写的是"不需要"而不是"不可以",当"临时代码"需要引用其他类库时也没有限制,只要服务端程序能使用的类型和接口,临时代码都应当能直接引用
    - "临时代码"的执行结果能返回到客户端,执行结果可以包括程序中输出的信息及抛出的异常等

### 思路

- 程序实现的三个问题
    - 如何编译提交到服务器的Java代码
    - 如何执行编译之后的Java代码
    - 如何收集Java代码的执行结果

### 实现

