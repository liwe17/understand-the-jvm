# 虚拟机字节码执行引擎

- 代码编译的结果从本地机器码转变为字节码,是存储格式发展的一小步,却是编程语言发展的一大步

## 概述

- 执行引擎是Java虚拟机核心的组成部分之一
- 所有的Java虚拟机的执行引擎输入,输出都是一致的:输入的是字节码二进制流,处理过程是字节码解析执行的等效过程,输出的是执行结果

## 运行时栈帧结构

- Java虚拟机以方法作为最基本的执行单元,栈帧(Stack Frame)是用于支持虚拟机进行方法调用和执行背后的数据结构,它也是虚拟机运行时数据区中的虚拟机栈的栈元素
- 栈帧存储了方法的局部变量表,操作数栈,动态链接的方法返回地址和一些额外的附加信息
- 每个方法从调用开始至结束的过程,都对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程
    - 一个线程中的方法调用链可能会很长,以Java程序的角度来看,同一时刻同一条线程里面,在调用堆栈的所有方法都同时处于执行状态
    - 对于执行引擎来讲,在活动线程中,只有位于栈顶的方法才是在运行的,只有位于栈顶的栈帧才是生效的,称为当前栈帧(Current Stack Frame),与这个栈帧所关联的方法称为当前方法
    - 执行引擎所运行的所有字节码指令都只针对当前栈帧进行操作

### 局部变量表

- 局部变量表(Local Variables Table)是一组变量值的存储空间,用于存放方法参数和方法内部定义的局部变量
    - 在编译成class文件时,就在方法的Code属性的max_locals数据项中确定了该方法所需分配的局部变量表的最大容量
    - 局部变量表的容量以变量槽(Variable Slot)为最小单位
        - Java中占用不超过32位存储空间的数据类型有boolean,byte,char,short,int,float,reference和returnAddress这8种类型
            - reference类型表示对一个对象实例的引用
            - returnAddress类型已经很少见了,它是为字节码指令jsr,jsr_w和ret服务的,指向了一条字节码指令的地址
        - Java语言中明确的64位的数据类型只有long和double两种
            - 把long和double数据类型分割存储的做法,由于是线程私有数据,无论读写两个连续的变量槽是否为原子操作,都不会引起数据竞争和线程安全问题
            - 如果访问的是64位数据类型的变量,则说明会同时使用第N和N+1两个变量槽,对于两个相邻的共同存放一个64位数据的两个变量槽,虚拟机不允许采用任何方式单独访问其中的某一个
    - Java虚拟机通过索引定位的方式使用局部变量表,索引值的范围是从0开始至局部变量表最大的变量槽数量
    - 当一个方法被调用时,Java虚拟机会使用局部变量表来完成参数值到参数变量列表的传递过程,即实参到形参的传递
        - 如果执行的是实例方法(没有被static修饰的方法)
          ,那局部变量表中第0位索引的变量槽默认是用于传递方法所属对象实例的引用,在方法中可以通过关键字this来访问到这个隐含的参数.其余参数则按照参数表顺序排列,占用从1开始的局部变量槽,参数表分配完毕后,再根据方法体内部定义的变量顺序和作用域分配其余的变量槽
        - 为了尽可能节省栈帧耗用的内存空间,局部变量表中的变量槽是可以重用的
        - 方法体中定义的变量,其作用域并不一定会覆盖整个方法体,如果当前字节码PC计数器的值已经超出了某个变量的作用域,那这个变量对应的变量槽就可以交给其他变量来重用
        - 复用变量槽会伴随有少量额外的副作用,在某些情况下变量槽的复用会直接影响到系统的垃圾收集行为

- 业务代码
    - com.weiliai.chapter7.VariableSlotTest

### 操作数栈

- 操作数栈(Operand Stack)也常被称为操作栈,它是一个后入先出(LIFO)栈
    - 同局部变量表一样,操作数栈的最大深度也在编译的时候被写入到Code属性的max_stacks数据项之中
    - 操作数栈的每一个元素都可以是包括long和double在内的任意Java数据类型.32位数据类型所占的栈容量为1,64位数据类型所占的栈容量为2
- 当一个方法刚刚开始执行的时候,这个方法的操作数栈是空的,在方法的执行过程中,会有各种字节码指令往操作数栈中写入和提取内容,也就是出栈和入栈操作

### 动态连接

- 每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用,持有这个引用是为了支持方法调用过程中的动态连接(Dynamic Linking)

### 方法返回地址

- 当一个方法开始执行后,只有两种方式退出这个方法
    - 一种方式是执行引擎遇到任意一个方法返回的字节码指令,这时候可能会有返回值传递给上层的方法调用者(调用当前方法的方法称为调用者或者主调方法)
      ,方法是否有返回值以及返回值的类型将根据遇到何种方法返回指令来决定,这种退出方法的方式称为正常调用完成(Normal Method Invocation Completion)
    - 一种退出方式是在方法执行的过程中遇到了异常,并且这个异常没有在方法体内得到妥善处理
        - 无论是Java虚拟机内部产生的异常,还是代码中使用athrow字节码指令产生的异常,只要在本方法的异常表中没有搜索到匹配的异常处理器,就会导致方法退出,这种退出方法的方式称为异常调用完成(Abrupt Method
          Invocation Completion)
        - 一个方法使用异常完成出口的方式退出,是不会给它的上层调用者提供任何返回值的

### 附加信息

- <Java虚拟机规范>允许虚拟机实现增加一些规范里没有描述的信息到栈帧之中,例如与调试,性能收集相关的信息,这部分信息完全取决于具体的虚拟机实现

## 方法调用

- 方法调用并不等同于方法中的代码被执行,方法调用阶段唯一的任务就是确定被调用方法的版本(即调用哪一个方法),暂时还未涉及方法内部的具体运行过程.在程序运行时,进行方法调用是最普遍,最频繁的操作之一
- Class文件的编译过程中不包含传统程序语言编译的连接步骤,一切方法调用在Class文件里面存储的都只是符号引用,而不是方法在实际运行时内存布局中的入口地址(也就是之前说的直接引用)
- 这个特性给Java带来了更强大的动态扩展能力,但也使得Java方法调用过程变得相对复杂,某些调用需要在类加载期间,甚至到运行期间才能确定目标方法的直接引用

### 解析

- 所有方法调用的目标方法在Class文件里面都是一个常量池中的符号引用,在类加载的解析阶段,会将其中的一部分符号引用转化为直接引用
    - 这种解析前提是:方法在程序真正运行之前就有一个可确定的调用版本并且这个方法的调用版本在运行期是不可改变的
- 调用目标在程序代码写好,编译器进行编译那一刻就已经确定下来.这类方法的调用被称为解析(Resolution)
    - 在Java语言中符合编译期可知,运行期不可变这个要求的方法,主要有静态方法和私有方法两大类.
        - 前者与类型直接关联,后者在外部不可被访问,这两种方法各自的特点决定了它们都不可能通过继承或别的方式重写出其他版本,因此它们都适合在类加载阶段进行解析

- 调用不同类型的方法,字节码指令集里设计了不同的指令,在Java虚拟机支持以下5条方法调用字节码指令
    - invokestatic:用于调用静态方法
    - invokespecial:用于调用实例构造器<init>()方法,私有方法和父类中的方法
    - invokevirtual:用于调用所有的虚方法
    - invokeinterface:用于调用接口方法,会在运行时再确定一个实现该接口的对象
    - invokedynamic:先在运行时动态解析出调用点限定符所引用的方法,然后再执行该方法,前面4条调用指令,分派逻辑都固化在Java虚拟机内部,而invokedynamic指令的分派逻辑是由用户设定的引导方法来决定的

- 只要能被invokestatic和invokespecial指令调用的方法,都可以在解析阶段中确定唯一的调用版本,Java语言里符合这个条件的方法共有静态方法,私有方法,实例构造器,父类方法4种,再加上被final修饰的方法(
  尽管它使用invokevirtual指令调用),这5种方法调用会在类加载的时候就可以把符号引用解析为该方法的直接引用,这些方法统称为非虚方法(Non-Virtual Method),与之相反,其他方法就被称为虚方法(Virtual
  Method)

- 解析调用一定是个静态的过程,在编译期间就完全确定,在类加载的解析阶段就会把涉及的符号引用全部转变为明确的直接引用,不必延迟到运行期再去完成

### 分派

- 分派(Dispatch)调用则要复杂许多,它可能是静态的也可能是动态的,按照分派依据的宗量数可分为单分派和多分派.这两类分派方式两两组合就构成了静态单分派,静态多分派,动态单分派,动态多分派4种分派组合情况
- Java是一门面向对象的程序语言,分派调用过程将会揭示多态性特征的一些最基本体现,如重载和重写在Java虚拟机之中是如何实现的

### 静态分派

- 所有依赖静态类型来决定方法执行版本的分派动作,都称为静态分派
    - 静态分派的最典型应用表现就是方法重载
    - 静态分派发生在编译阶段,因此确定静态分派的动作实际上不是由虚拟机来执行的

- StaticDispatch代码演示了编译期间选择静态分派目标的过程,这个过程也是Java语言实现方法重载的本质

- 业务代码
    - com.weiliai.chapter8.Overload
    - com.weiliai.chapter8.StaticDispatch

### 动态分派

- Java语言里动态分派的实现过程,它与Java语言多态性的另外一个重要体现-重写(override)有着密切的关联
- 在运行期根据实际类型确定方法执行版本的分派过程称为动态分派

- invokevirtual指令的运行时解析过程,这个过程就是Java语言中方法重写的本质.
    - 找到操作数栈顶的第一个元素所指向的对象的实际类型,记作C
    - 如果在类型C中找到与常量中的描述符和简单名称都相符的方法,则进行访问权限校验,如果通过则返回这个方法的直接引用,查找过程结束;不通过则返回java.lang.IllegalAccessError异常
    - 否则,按照继承关系从下往上依次对C的各个父类进行第二步的搜索和验证过程
    - 如果始终没有找到合适的方法,则抛出java.lang.AbstractMethodError异常

- 业务代码
    - com.weiliai.chapter8.DynamicDispatch
    - com.weiliai.chapter8.FieldHasNoPolymorphic

### 单分派与多分派

- 方法的接收者与方法的参数统称为方法的宗量,根据分派基于多少种宗量,可以将分派划分为单分派和多分派两种
    - 单分派是根据一个宗量对目标方法进行选择
    - 多分派则是根据多于一个宗量对目标方法进行选择

- Java语言是一门静态多分派,动态单分派的语言

- 业务代码
    - com.weiliai.chapter8.Dispatch

### 虚拟机动态分派的实现

- 动态分派是执行非常频繁的动作,而且动态分派的方法版本选择过程需要运行时在接收者类型的方法元数据中搜索合适的目标方法

## 动态类型语言支持

- Java虚拟机的字节码指令集的数量自从Sun公司的第一款Java虚拟机问世至今,仅在JDK7新增首位新成员-invokedynamic指令
- invokedynamic指令的目标
    - 实现动态类型语言(Dynamically Typed Language)支持而进行的改进之一
    - 为JDK8里可以顺利实现Lambda表达式而做的技术储备

### 动态类型语言

- 动态类型语言的关键特征是它的类型检查的主体过程是在运行期而不是编译期进行的,变量无类型而变量值才有类型也是一个核心特征
- 静态类型语言能够在编译期确定变量类型,最显著的好处是编译器可以提供全面严谨的类型检查,这样与数据类型相关的潜在问题就能在编码时被及时发现,利于稳定性及让项目容易达到更大的规模
- 动态类型语言在运行期才确定类型,这可以为开发人员提供极大的灵活性,某些在静态类型语言中要花大量臃肿代码来实现的功能,由动态类型语言去做可能会很清晰简洁,清晰简洁通常也就意味着开发效率的提升

### Java与动态类型

### java.lang.invoke包

- JDK7时新加入的java.lang.invoke包是JSR292的一个重要组成部分,这个包的主要目的是在之前单纯依靠符号引用来确定调用的目标方法这条路之外,提供一种新的动态确定目标方法的机制,称为方法句柄(Method Handle)

- 站在Java语言的角度看,MethodHandle与Reflection区别
    - Reflection和MethodHandle机制本质上都是在模拟方法调用,但是Reflection是在模拟Java代码层次的方法调用,而MethodHandle是在模拟字节码层次的方法调用
        - 在MethodHandles.Lookup上的3个方法findStatic(),findVirtual(),findSpecial()
          正是对应于invokestatic,invokevirtual以及invokeinterface和invokespecial这几条字节码指令的执行权限校验行为,而这些底层细节在使用Reflection
          API时是不需要关心的.
    - Reflection中的java.lang.reflect.Method对象远比MethodHandle机制中的java.lang.invoke.MethodHandle对象所包含的信息来得多.
        - 前者是方法在Java端的全面映像,包含了方法的签名,描述符以及方法属性表中各种属性的Java端表示方式,还包含执行权限等的运行期信息.
        - 后者仅包含执行该方法的相关信息.用开发人员通俗的话来讲,Reflection是重量级,而MethodHandle是轻量级.
    - 由于MethodHandle是对字节码的方法指令调用的模拟
        - 那理论上虚拟机在这方面做的各种优化(如方法内联),在MethodHandle上也应当可以采用类似思路去支持(但目前实现还在继续完善中),而通过反射去调用方法则几乎不可能直接去实施各类调用点优化措施

- 业务代码
    - com.weiliai.chapter8.MethodHandleTest

### invokedynamic指令

- 每一处含有invokedynamic指令的位置都被称作,动态调用点(Dynamically-Computed Call Site)
    - 指令的第一个参数不再是代表方法符号引用的CONSTANT_Methodref_info常量,而是变为JDK 7时新加入的CONSTANT_InvokeDynamic_info常量
    - CONSTANT_InvokeDynamic_info常量包含引导方法(Bootstrap Method,该方法存放在新增的BootstrapMethods属性中),方法类型(MethodType)和名称
        - 引导方法是有固定的参数并且返回值规定是java.lang.invoke.CallSite对象,这个对象代表了真正要执行的目标方法调用
- 根据CONSTANT_InvokeDynamic_info常量中提供的信息,虚拟机可以找到并且执行引导方法,从而获得一个CallSite对象,最终调用到要执行的目标方法上

- 业务代码
    - com.weiliai.chapter8.InvokeDynamicTest

### 实战:掌控方法分派规则

- invokedynamic指令与此前4条传统的"invoke*"指令的最大区别就是它的分派逻辑不是由虚拟机决定的,而是由程序员决定

- 业务代码
    - com.weiliai.chapter8.MethodInvokeTest

## 基于栈的字节码解释执行引擎

- 许多Java虚拟机的执行引擎在执行Java代码的时候都有解释执行(通过解释器执行)和编译执行(通过即时编译器产生本地代码执行)两种选择

### 解析执行

- Java语言经常被人们定位为解释执行的语言
    - 在JDK1.0时代比较准确
    - 当主流的虚拟机中都包含了即时编译器后,Class文件中的代码到底会被解释执行还是编译执行,就成了只有虚拟机自己才能准确判断的事
    - 后来,Java也发展出可以直接生成本地代码的编译器

- 只有确定了谈论对象是某种具体的Java实现版本和执行引擎运行模式时,谈解释执行还是编译执行才会比较合理确切

- 在Java语言中,Javac编译器完成了程序代码经过词法分析,语法分析到抽象语法树,再遍历语法树生成线性的字节码指令流的过程.因为这一部分动作是在Java虚拟机之外进行的,而解释器在虚拟机的内部,所以Java程序的编译就是半独立的实现

### 基于栈的指令集与基于寄存器的指令集

- Javac编译器输出的字节码指令流,基本上是一种基于栈的指令集架构(Instruction Set Architecture,ISA),字节码指令流里面的指令大部分都是零地址指令,它们依赖操作数栈进行工作
- 与之相对的另外一套常用的指令集架构是基于寄存器的指令集,最典型的就是x86的二地址指令集

- 两种指令的例子,计算1+1

```
ISA指令

iconst_1
iconst_1
iadd
istore_0

两条iconst_1指令连续把两个常量1压入栈后,iadd指令把栈顶的两个值出栈,相加,然后把结果放回栈顶,最后istore_0把栈顶的值放到局部变量表的第0个变量槽中.
这种指令流中的指令通常都是不带参数的,使用操作数栈中的数据作为指令的运算输入,指令的运算结果也存储在操作数栈之中

mov  eax, 1
add  eax, 1

mov指令把EAX寄存器的值设为1,然后add指令再把这个值加1,结果就保存在EAX寄存器里面.
这种二地址指令是x86指令集中的主流,每个指令都包含两个单独的输入参数,依赖于寄存器来访问和存储数据
```

- 基于栈的指令集主要优点是可移植,因为寄存器由硬件直接提供,程序直接依赖这些硬件寄存器则不可避免地要受到硬件的约束
- 在解释执行时,栈架构指令集的代码虽然紧凑,但是完成相同功能所需的指令数量一般会比寄存器架构来得更多
    - 因为出栈,入栈操作本身就产生了相当大量的指令
    - 更重要的是栈实现在内存中,频繁的栈访问也就意味着频繁的内存访问,相对于处理器,内存始终是执行速度的瓶颈

### 基于栈的解释器执行过程

```
public int calc() {
    int a = 100;
    int b = 200;
    int c = 300;
    return (a + b) * c;
}

public int calc();
    Code:
        Stack=2, Locals=4, Args_size=1
         0:   bipush  100
         2:   istore_1
         3:   sipush  200
         6:   istore_2
         7:   sipush  300
        10:  istore_3
        11:  iload_1
        12:  iload_2
        13:  iadd
        14:  iload_3
        15:  imul
        16:  ireturn
}
```

- 要深度为2的操作数栈和4个变量槽的局部变量空间
    - 首先,执行偏移地址为0的指令,Bipush指令的作用是将单字节的整型常量值(-128～127)推入操作数栈顶,跟随有一个参数,指明推送的常量值,这里是100.
    - 执行偏移地址为2的指令,istore_1指令的作用是将操作数栈顶的整型值出栈并存放到第1个局部变量槽中.后续4条指令(直到偏移为11的指令为止)都是做一样的事情,也就是在对应代码中把变量a,b,c赋值为100,200,3
    - 执行偏移地址为11的指令,iload_1指令的作用是将局部变量表第1个变量槽中的整型值复制到操作数栈顶
    - 执行偏移地址为12的指令,iload_2指令的执行过程与iload_1类似,把第2个变量槽的整型值入栈.画出这个指令的图示主要是为了显示下一条iadd指令执行前的堆栈状况
    - 执行偏移地址为13的指令,iadd指令的作用是将操作数栈中头两个栈顶元素出栈,做整型加法,然后把结果重新入栈.在iadd指令执行完毕后,栈中原有的100和200被出栈,它们的和300被重新入栈
    - 执行偏移地址为14的指令,iload_3指令把存放在第3个局部变量槽中的300入栈到操作数栈中.这时操作数栈为两个整数300.下一条指令imul是将操作数栈中头两个栈顶元素出栈,做整型乘法,然后把结果重新入栈,与iadd完全类似
    - 执行偏移地址为16的指令,ireturn指令是方法返回指令之一,它将结束方法执行并将操作数栈顶的整型值返回给该方法的调用者.到此为止,这段方法执行结束















