# 虚拟机字节码执行引擎

- 代码编译的结果从本地机器码转变为字节码,是存储格式发展的一小步,却是编程语言发展的一大步

## 概述

- 执行引擎是Java虚拟机核心的组成部分之一
- 所有的Java虚拟机的执行引擎输入,输出都是一致的:输入的是字节码二进制流,处理过程是字节码解析执行的等效过程,输出的是执行结果

## 运行时栈帧结构

- Java虚拟机以方法作为最基本的执行单元,栈帧(Stack Frame)是用于支持虚拟机进行方法调用和执行背后的数据结构,它也是虚拟机运行时数据区中的虚拟机栈的栈元素
- 栈帧存储了方法的局部变量表,操作数栈,动态链接的方法返回地址和一些额外的附加信息
- 每个方法从调用开始至结束的过程,都对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程
    - 一个线程中的方法调用链可能会很长,以Java程序的角度来看,同一时刻同一条线程里面,在调用堆栈的所有方法都同时处于执行状态
    - 对于执行引擎来讲,在活动线程中,只有位于栈顶的方法才是在运行的,只有位于栈顶的栈帧才是生效的,称为当前栈帧(Current Stack Frame),与这个栈帧所关联的方法称为当前方法
    - 执行引擎所运行的所有字节码指令都只针对当前栈帧进行操作

### 局部变量表

- 局部变量表(Local Variables Table)是一组变量值的存储空间,用于存放方法参数和方法内部定义的局部变量
    - 在编译成class文件时,就在方法的Code属性的max_locals数据项中确定了该方法所需分配的局部变量表的最大容量
    - 局部变量表的容量以变量槽(Variable Slot)为最小单位
        - Java中占用不超过32位存储空间的数据类型有boolean,byte,char,short,int,float,reference和returnAddress这8种类型
            - reference类型表示对一个对象实例的引用
            - returnAddress类型已经很少见了,它是为字节码指令jsr,jsr_w和ret服务的,指向了一条字节码指令的地址
        - Java语言中明确的64位的数据类型只有long和double两种
            - 把long和double数据类型分割存储的做法,由于是线程私有数据,无论读写两个连续的变量槽是否为原子操作,都不会引起数据竞争和线程安全问题
            - 如果访问的是64位数据类型的变量,则说明会同时使用第N和N+1两个变量槽,对于两个相邻的共同存放一个64位数据的两个变量槽,虚拟机不允许采用任何方式单独访问其中的某一个
    - Java虚拟机通过索引定位的方式使用局部变量表,索引值的范围是从0开始至局部变量表最大的变量槽数量
    - 当一个方法被调用时,Java虚拟机会使用局部变量表来完成参数值到参数变量列表的传递过程,即实参到形参的传递
        - 如果执行的是实例方法(没有被static修饰的方法)
          ,那局部变量表中第0位索引的变量槽默认是用于传递方法所属对象实例的引用,在方法中可以通过关键字this来访问到这个隐含的参数.其余参数则按照参数表顺序排列,占用从1开始的局部变量槽,参数表分配完毕后,再根据方法体内部定义的变量顺序和作用域分配其余的变量槽
        - 为了尽可能节省栈帧耗用的内存空间,局部变量表中的变量槽是可以重用的
        - 方法体中定义的变量,其作用域并不一定会覆盖整个方法体,如果当前字节码PC计数器的值已经超出了某个变量的作用域,那这个变量对应的变量槽就可以交给其他变量来重用
        - 复用变量槽会伴随有少量额外的副作用,在某些情况下变量槽的复用会直接影响到系统的垃圾收集行为

- 业务代码
    - com.weiliai.chapter7.VariableSlotTest

### 操作数栈

- 操作数栈(Operand Stack)也常被称为操作栈,它是一个后入先出(LIFO)栈
    - 同局部变量表一样,操作数栈的最大深度也在编译的时候被写入到Code属性的max_stacks数据项之中
    - 操作数栈的每一个元素都可以是包括long和double在内的任意Java数据类型.32位数据类型所占的栈容量为1,64位数据类型所占的栈容量为2
- 当一个方法刚刚开始执行的时候,这个方法的操作数栈是空的,在方法的执行过程中,会有各种字节码指令往操作数栈中写入和提取内容,也就是出栈和入栈操作

### 动态连接

- 每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用,持有这个引用是为了支持方法调用过程中的动态连接(Dynamic Linking)

### 方法返回地址

- 当一个方法开始执行后,只有两种方式退出这个方法
    - 一种方式是执行引擎遇到任意一个方法返回的字节码指令,这时候可能会有返回值传递给上层的方法调用者(调用当前方法的方法称为调用者或者主调方法)
      ,方法是否有返回值以及返回值的类型将根据遇到何种方法返回指令来决定,这种退出方法的方式称为正常调用完成(Normal Method Invocation Completion)
    - 一种退出方式是在方法执行的过程中遇到了异常,并且这个异常没有在方法体内得到妥善处理
        - 无论是Java虚拟机内部产生的异常,还是代码中使用athrow字节码指令产生的异常,只要在本方法的异常表中没有搜索到匹配的异常处理器,就会导致方法退出,这种退出方法的方式称为异常调用完成(Abrupt Method
          Invocation Completion)
        - 一个方法使用异常完成出口的方式退出,是不会给它的上层调用者提供任何返回值的

### 附加信息

- <Java虚拟机规范>允许虚拟机实现增加一些规范里没有描述的信息到栈帧之中,例如与调试,性能收集相关的信息,这部分信息完全取决于具体的虚拟机实现

## 方法调用

- 方法调用并不等同于方法中的代码被执行,方法调用阶段唯一的任务就是确定被调用方法的版本(即调用哪一个方法),暂时还未涉及方法内部的具体运行过程.在程序运行时,进行方法调用是最普遍,最频繁的操作之一
- Class文件的编译过程中不包含传统程序语言编译的连接步骤,一切方法调用在Class文件里面存储的都只是符号引用,而不是方法在实际运行时内存布局中的入口地址(也就是之前说的直接引用)
- 这个特性给Java带来了更强大的动态扩展能力,但也使得Java方法调用过程变得相对复杂,某些调用需要在类加载期间,甚至到运行期间才能确定目标方法的直接引用

### 解析

- 所有方法调用的目标方法在Class文件里面都是一个常量池中的符号引用,在类加载的解析阶段,会将其中的一部分符号引用转化为直接引用
    - 这种解析前提是:方法在程序真正运行之前就有一个可确定的调用版本并且这个方法的调用版本在运行期是不可改变的
- 调用目标在程序代码写好,编译器进行编译那一刻就已经确定下来.这类方法的调用被称为解析(Resolution)
    - 在Java语言中符合编译期可知,运行期不可变这个要求的方法,主要有静态方法和私有方法两大类.
        - 前者与类型直接关联,后者在外部不可被访问,这两种方法各自的特点决定了它们都不可能通过继承或别的方式重写出其他版本,因此它们都适合在类加载阶段进行解析

- 调用不同类型的方法,字节码指令集里设计了不同的指令,在Java虚拟机支持以下5条方法调用字节码指令
    - ·invokestatic:用于调用静态方法 ·invokespecial:用于调用实例构造器<init>()方法,私有方法和父类中的方法 ·invokevirtual:用于调用所有的虚方法 ·invokeinterface:
      用于调用接口方法,会在运行时再确定一个实现该接口的对象 ·invokedynamic:先在运行时动态解析出调用点限定符所引用的方法,然后再执行该方法:
      前面4条调用指令,分派逻辑都固化在Java虚拟机内部,而invokedynamic指令的分派逻辑是由用户设定的引导方法来决定的

- 只要能被invokestatic和invokespecial指令调用的方法,都可以在解析阶段中确定唯一的调用版本,Java语言里符合这个条件的方法共有静态方法,私有方法,实例构造器,父类方法4种,再加上被final修饰的方法(
  尽管它使用invokevirtual指令调用),这5种方法调用会在类加载的时候就可以把符号引用解析为该方法的直接引用,这些方法统称为非虚方法(Non-Virtual Method),与之相反,其他方法就被称为虚方法(Virtual
  Method)

- 解析调用一定是个静态的过程,在编译期间就完全确定,在类加载的解析阶段就会把涉及的符号引用全部转变为明确的直接引用,不必延迟到运行期再去完成

### 分派

- 分派(Dispatch)调用则要复杂许多,它可能是静态的也可能是动态的,按照分派依据的宗量数可分为单分派和多分派.这两类分派方式两两组合就构成了静态单分派,静态多分派,动态单分派,动态多分派4种分派组合情况
- Java是一门面向对象的程序语言,分派调用过程将会揭示多态性特征的一些最基本体现,如重载和重写在Java虚拟机之中是如何实现的

### 静态分派

