# 虚拟机类加载机制

- 代码编译的结果从本地机器码转变为字节码,是存储格式发展的一小步,却是编程语言发展的一大步

## 概述

- 在Class文件中描述的各类信息,最终都需要加载到虚拟机中之后才能被运行和使用
- Java虚拟机把描述类的数据从Class文件加载到内存,并对数据进行校验,转换解析和初始化,最终形成可以被虚拟机直接使用的Java类型,这个过程被称作虚拟机的类加载机制
- 在Java语言中,类型的加载,连接和初始化过程都是在程序运行期间完成的
    - 这种策略让Java语言进行提前编译会面临额外的困难,也会让类加载时稍微增加一些性能开销,但是却为Java应用提供了极高的扩展性和灵活性
    - Java天生可以动态扩展的语言特性就是依赖运行期动态加载和动态连接这个特点实现的

## 类加载的时机

- 一个类型从被加载到虚拟机内存中开始,到卸载出内存为止,它的整个生命周期将会经历加载(loading),验证(verification),准备(preparation),解析(resolution),初始化(initialization)
  ,使用(using)和卸载(Unloading)7个阶段,其中验证,准备,解析三个部分统称为连接

- 加载,验证,准备,初始化和卸载这五个阶段的顺序是确定的,类型的加载过程必须按照这种顺序按部就班地开始,而解析阶段则不一定,在某些情况下,可以在初始化之后执行,这是为了支持Java语言的运行时绑定特性(也称动态绑定或晚期绑定)

- 加载在虚拟机规范中没有强制约束,这点取决于虚拟机的具体实现,但是初始化是严格规定了有且只有六种情况必须立即对类进行"初始化",这六种场景中的行为称为对一个类型进行主动引用,除此之外,所有引用类型的方式都不会触发初始化,称为被动引用
    - 遇到new,getstatic,putstatic或invokestatic这四条字节码指令时,如果类型没有进行过初始化,则需要先触发其初始化阶段
        - 使用new关键字实例化对象的时候
        - 调用一个类型的静态方法的时候
        - 读取或设置一个类型的静态字段(被final修饰,已在编译期把结果放入常量池的静态字段除外)的时候
    - 使用java.lang.reflect包的方法对类型进行反射调用的时候,如果类型没有进行过初始化,则需要先触发其初始化
    - 当初始化类的时候,如果发现其父类还没有进行过初始化,则需要先触发其父类的初始化
    - 当虚拟机启动时,用户需要指定一个要执行的主类(main()方法的类),虚拟机会先初始化这个主类
    -
  当使用JDK7新加入的动态语言支持时,如果一个java.lang.invoke.MethodHandle实例最后的解析结果为REF_getStatic,REF_putStatic,REF_invokeStatic,REF_newInvokeSpecial四种类型的方法句柄,并且这个方法句柄对应的类没有进行过初始化,则需要先触发其初始化
    - 当一个接口中定义了JDK 8新加入的默认方法(被default关键字修饰的接口方法)时,如果有这个接口的实现类发生了初始化,那该接口要在其之前被初始化

- 业务代码
    - com.weiliai.chapter7.NotInitialization

## 类加载的过程

- Java虚拟机中类加载的全过程,即加载,验证,准备,解析和初始化这五个阶段所执行的具体动作

### 加载

- 加载(Loading)阶段是整个"类加载"(Class Loading)过程中的一个阶段,在加载阶段,主要完成三件事
    - 通过一个类的全限定名来获取定义此类的二进制字节流
    - 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
    - 在内存中生成一个代表这个类的java.lang.Class对象,作为方法区这个类的各种数据的访问入口

- 非数组类型的加载阶段(准确地说,是加载阶段中获取类的二进制字节流的动作)是开发人员可控性最强的阶段
    - 加载阶段既可以使用Java虚拟机里内置的引导类加载器来完成,也可以由用户自定义的类加载器去完成
    - 开发人员通过定义自己的类加载器去控制字节流的获取方式(重写一个类加载器的findClass()或loadClass()方法),实现运行代码动态性

- 对于数据类而言,数组类本身不通过类加载器创建,它是有Java虚拟机直接在内存中动态构造出来的,但数组类与类加载器仍然有很密切的关系,因为数组类的元素类型(ElementType,指的是数组去掉所有维度的类型)
  最终还是要靠类加载器来完成加载

- 加载阶段结束后,Java虚拟机外部的二进制字节流就按照虚拟机所设定的格式存储在方法区之中了,方法区中的数据存储格式完全由虚拟机实现自行定义,<Java虚拟机规范>未规定此区域的具体数据结构

### 验证

- 验证是连接阶段的第一步,这一阶段的目的是确保Class文件的字节流中包含的信息符合<Java虚拟机规范>的全部约束要求,保证这些信息被当作代码运行不会危害虚拟机自身的安全

- 验证阶段从整体上看,大致上会完成四个阶段的检验动作
    - 第一阶段:文件格式验证
        - 第一阶段要验证字节流是否符合Class文件格式的规范,并且能被当前版本的虚拟机处理,该验证阶段的主要目的是保证输入的字节流能正确地解析并存储于方法区之内,格式上符合描述一个Java类型信息的要求
        - 后面的三个验证阶段全部是基于方法区的存储结构上进行的,不会再直接读取,操作字节流了
            - 是否以魔数0xCAFEBABE开头
            - 主,次版本号是否在当前Java虚拟机接受范围之内
            - 等
    - 第二阶段:元数据验证
        - 第二阶段是对字节码描述的信息进行语义分析,保证不存在与<Java语言规范>定义相悖的元数据信息
            - 这个类是否有父类(除了java.lang.Object之外,所有的类都应当有父类)
            - 这个类的父类是否继承了不允许被继承的类(被final修饰的类)
            - 等
    - 第三阶段:字节码验证
        - 第三阶段是整个验证过程中最复杂的一个阶段,主要目的是通过数据流分析和控制流分析,确定程序语义是合法的,符合逻辑的.
        - 对类的方法体(Class文件中的Code属性)进行校验分析,保证类的方法在运行时不会做出危害虚拟机安全的行为
            - 保证任何跳转指令都不会跳转到方法体以外的字节码指令上
            - 保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作,例如不会出现操作数栈上放置了int类型的数据,使用时使用long类型来加载入本地变量表中
            - 等
    - 第四阶段:符号引用验证
        - 最后一个阶段的校验行为发生在虚拟机将符号引用转化为直接引用的时候,这个转化动作将在连接的第三阶段—解析阶段中发生
        - 符号引用验证的主要目的是确保解析行为能正常执行
        - 符号引用验证可以看作是对类自身以外(常量池中的各种符号引用)的各类信息进行匹配性校验,该类是否缺少或者被禁止访问它依赖的某些外部类,方法,字段等资源
            - 符号引用中通过字符串描述的全限定名是否能找到对应的类
            - 在指定类中是否存在符合方法的字段描述符及简单名称所描述的方法和字段
            - 等

### 准备

- 准备阶段是正式为类中定义的变量(即静态变量,被static修饰的变量)分配内存并设置类变量初始值的阶段
    - 首先是这时候进行内存分配的仅包括类变量,而不包括实例变量,实例变量将会在对象实例化时随着对象一起分配在Java堆中
    - 其次是这里所说的初始值,通常情况下是数据类型的零值.特殊情况,如果类字段的字段属性表中存在ConstantValue属性,那么在准备阶段就会被附上初值,例如final修饰的

### 解析

- 解析阶段是Java虚拟机将常量池内的符号引用替换为直接引用的过程.

- 直接引用与符号引用的关联
    - 符号引用(Symbolic References):符号引用以一组符号来描述所引用的目标,符号可以是任何形式的字面量,只要使用时能无歧义地定位到目标即可.
        - 符号引用的字面量形式明确定义在<Java虚拟机规范>的Class文件格式中
        - 符号引用与虚拟机实现的内存布局无关,引用的目标并不一定是已经加载到虚拟机内存当中的内容
    - 直接引用(Direct References):直接引用是可以直接指向目标的指针,相对偏移量或者是一个能间接定位到目标的句柄
        - 直接引用是和虚拟机实现的内存布局直接相关的,同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同,如果有了直接引用,那引用目标必定已经存在于虚拟机的内存中

- 解析动作主要针对类或接口,字段,类方法,接口方法,方法类型,方法句柄和调用点限定符这7类符号引用进行,对应于常量池的
    - CONSTANT_Class_info
    - CON-STANT_Fieldref_info
    - CONSTANT_Methodref_info
    - CONSTANT_InterfaceMethodref_info
    - CONSTANT_MethodType_info
    - CONSTANT_MethodHandle_info
    - CONSTANT_Dyna-mic_info和CONSTANT_InvokeDynamic_info8种常量类型

### 初始化

- 类的初始化阶段是类加载过程的最后一个步骤,进行准备阶段时,变量已经赋过一次系统要求的初始零值,而在初始化阶段,则会根据程序员通过程序编码制定的主观计划去初始化类变量和其他资源
- 初始化阶段就是执行类构造器<clinit>()方法的过程
    - <clinit>()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{}块）中的语句合并产生的
    - 编译器收集的顺序是由语句在源文件中出现的顺序决定的
    - 静态语句块中只能访问到定义在静态语句块之前的变量,定义在它之后的变量,在前面的静态语句块可以赋值,但是不能访问

## 类加载器

- "通过一个类的全限定名来获取描述该类的二进制字节流"实现这个动作的代码被称为"类加载器"(Class Loader)

### 类与类加载器

