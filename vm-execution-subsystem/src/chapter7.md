# 虚拟机类加载机制

- 代码编译的结果从本地机器码转变为字节码,是存储格式发展的一小步,却是编程语言发展的一大步

## 概述

- 在Class文件中描述的各类信息,最终都需要加载到虚拟机中之后才能被运行和使用
- Java虚拟机把描述类的数据从Class文件加载到内存,并对数据进行校验,转换解析和初始化,最终形成可以被虚拟机直接使用的Java类型,这个过程被称作虚拟机的类加载机制
- 在Java语言中,类型的加载,连接和初始化过程都是在程序运行期间完成的
    - 这种策略让Java语言进行提前编译会面临额外的困难,也会让类加载时稍微增加一些性能开销,但是却为Java应用提供了极高的扩展性和灵活性
    - Java天生可以动态扩展的语言特性就是依赖运行期动态加载和动态连接这个特点实现的

## 类加载的时机

- 一个类型从被加载到虚拟机内存中开始,到卸载出内存为止,它的整个生命周期将会经历加载(loading),验证(verification),准备(preparation),解析(resolution),初始化(initialization)
  ,使用(using)和卸载(Unloading)7个阶段,其中验证,准备,解析三个部分统称为连接

- 加载,验证,准备,初始化和卸载这五个阶段的顺序是确定的,类型的加载过程必须按照这种顺序按部就班地开始,而解析阶段则不一定,在某些情况下,可以在初始化之后执行,这是为了支持Java语言的运行时绑定特性(也称动态绑定或晚期绑定)

- 加载在虚拟机规范中没有强制约束,这点取决于虚拟机的具体实现,但是初始化是严格规定了有且只有六种情况必须立即对类进行"初始化",这六种场景中的行为称为对一个类型进行主动引用,除此之外,所有引用类型的方式都不会触发初始化,称为被动引用
    - 遇到new,getstatic,putstatic或invokestatic这四条字节码指令时,如果类型没有进行过初始化,则需要先触发其初始化阶段
        - 使用new关键字实例化对象的时候
        - 调用一个类型的静态方法的时候
        - 读取或设置一个类型的静态字段(被final修饰,已在编译期把结果放入常量池的静态字段除外)的时候
    - 使用java.lang.reflect包的方法对类型进行反射调用的时候,如果类型没有进行过初始化,则需要先触发其初始化
    - 当初始化类的时候,如果发现其父类还没有进行过初始化,则需要先触发其父类的初始化
    - 当虚拟机启动时,用户需要指定一个要执行的主类(main()方法的类),虚拟机会先初始化这个主类
    -
  当使用JDK7新加入的动态语言支持时,如果一个java.lang.invoke.MethodHandle实例最后的解析结果为REF_getStatic,REF_putStatic,REF_invokeStatic,REF_newInvokeSpecial四种类型的方法句柄,并且这个方法句柄对应的类没有进行过初始化,则需要先触发其初始化
    - 当一个接口中定义了JDK 8新加入的默认方法(被default关键字修饰的接口方法)时,如果有这个接口的实现类发生了初始化,那该接口要在其之前被初始化

- 业务代码
    - com.weiliai.chapter7.NotInitialization

## 类加载的过程

- Java虚拟机中类加载的全过程,即加载,验证,准备,解析和初始化这五个阶段所执行的具体动作

### 加载

- 加载(Loading)阶段是整个"类加载"(Class Loading)过程中的一个阶段,在加载阶段,主要完成三件事
    - 通过一个类的全限定名来获取定义此类的二进制字节流
    - 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
    - 在内存中生成一个代表这个类的java.lang.Class对象,作为方法区这个类的各种数据的访问入口

- 非数组类型的加载阶段(准确地说,是加载阶段中获取类的二进制字节流的动作)是开发人员可控性最强的阶段
    - 加载阶段既可以使用Java虚拟机里内置的引导类加载器来完成,也可以由用户自定义的类加载器去完成
    - 开发人员通过定义自己的类加载器去控制字节流的获取方式(重写一个类加载器的findClass()或loadClass()方法),实现运行代码动态性

- 对于数据类而言,数组类本身不通过类加载器创建,它是有Java虚拟机直接在内存中动态构造出来的,但数组类与类加载器仍然有很密切的关系,因为数组类的元素类型(ElementType,指的是数组去掉所有维度的类型)
  最终还是要靠类加载器来完成加载

- 加载阶段结束后,Java虚拟机外部的二进制字节流就按照虚拟机所设定的格式存储在方法区之中了,方法区中的数据存储格式完全由虚拟机实现自行定义,<Java虚拟机规范>未规定此区域的具体数据结构

### 验证

- 验证是连接阶段的第一步,这一阶段的目的是确保Class文件的字节流中包含的信息符合<Java虚拟机规范>的全部约束要求,保证这些信息被当作代码运行不会危害虚拟机自身的安全

- 验证阶段从整体上看,大致上会完成四个阶段的检验动作
    - 第一阶段:文件格式验证
        - 第一阶段要验证字节流是否符合Class文件格式的规范,并且能被当前版本的虚拟机处理,该验证阶段的主要目的是保证输入的字节流能正确地解析并存储于方法区之内,格式上符合描述一个Java类型信息的要求
        - 后面的三个验证阶段全部是基于方法区的存储结构上进行的,不会再直接读取,操作字节流了
            - 是否以魔数0xCAFEBABE开头
            - 主,次版本号是否在当前Java虚拟机接受范围之内
            - 等
    - 第二阶段:元数据验证
        - 第二阶段是对字节码描述的信息进行语义分析,保证不存在与<Java语言规范>定义相悖的元数据信息
            - 这个类是否有父类(除了java.lang.Object之外,所有的类都应当有父类)
            - 这个类的父类是否继承了不允许被继承的类(被final修饰的类)
            - 等
    - 第三阶段:字节码验证
        - 第三阶段是整个验证过程中最复杂的一个阶段,主要目的是通过数据流分析和控制流分析,确定程序语义是合法的,符合逻辑的.
        - 对类的方法体(Class文件中的Code属性)进行校验分析,保证类的方法在运行时不会做出危害虚拟机安全的行为
            - 保证任何跳转指令都不会跳转到方法体以外的字节码指令上
            - 保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作,例如不会出现操作数栈上放置了int类型的数据,使用时使用long类型来加载入本地变量表中
            - 等
    - 第四阶段:符号引用验证
        - 最后一个阶段的校验行为发生在虚拟机将符号引用转化为直接引用的时候,这个转化动作将在连接的第三阶段—解析阶段中发生
        - 符号引用验证的主要目的是确保解析行为能正常执行
        - 符号引用验证可以看作是对类自身以外(常量池中的各种符号引用)的各类信息进行匹配性校验,该类是否缺少或者被禁止访问它依赖的某些外部类,方法,字段等资源
            - 符号引用中通过字符串描述的全限定名是否能找到对应的类
            - 在指定类中是否存在符合方法的字段描述符及简单名称所描述的方法和字段
            - 等

### 准备

- 准备阶段是正式为类中定义的变量(即静态变量,被static修饰的变量)分配内存并设置类变量初始值的阶段
    - 首先是这时候进行内存分配的仅包括类变量,而不包括实例变量,实例变量将会在对象实例化时随着对象一起分配在Java堆中
    - 其次是这里所说的初始值,通常情况下是数据类型的零值.特殊情况,如果类字段的字段属性表中存在ConstantValue属性,那么在准备阶段就会被附上初值,例如final修饰的

### 解析

- 解析阶段是Java虚拟机将常量池内的符号引用替换为直接引用的过程.

- 直接引用与符号引用的关联
    - 符号引用(Symbolic References):符号引用以一组符号来描述所引用的目标,符号可以是任何形式的字面量,只要使用时能无歧义地定位到目标即可.
        - 符号引用的字面量形式明确定义在<Java虚拟机规范>的Class文件格式中
        - 符号引用与虚拟机实现的内存布局无关,引用的目标并不一定是已经加载到虚拟机内存当中的内容
    - 直接引用(Direct References):直接引用是可以直接指向目标的指针,相对偏移量或者是一个能间接定位到目标的句柄
        - 直接引用是和虚拟机实现的内存布局直接相关的,同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同,如果有了直接引用,那引用目标必定已经存在于虚拟机的内存中

- 解析动作主要针对类或接口,字段,类方法,接口方法,方法类型,方法句柄和调用点限定符这7类符号引用进行,对应于常量池的
    - CONSTANT_Class_info
    - CON-STANT_Fieldref_info
    - CONSTANT_Methodref_info
    - CONSTANT_InterfaceMethodref_info
    - CONSTANT_MethodType_info
    - CONSTANT_MethodHandle_info
    - CONSTANT_Dyna-mic_info和CONSTANT_InvokeDynamic_info8种常量类型

### 初始化

- 类的初始化阶段是类加载过程的最后一个步骤,进行准备阶段时,变量已经赋过一次系统要求的初始零值,而在初始化阶段,则会根据程序员通过程序编码制定的主观计划去初始化类变量和其他资源
- 初始化阶段就是执行类构造器<clinit>()方法的过程
    - <clinit>()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{}块）中的语句合并产生的
    - 编译器收集的顺序是由语句在源文件中出现的顺序决定的
    - 静态语句块中只能访问到定义在静态语句块之前的变量,定义在它之后的变量,在前面的静态语句块可以赋值,但是不能访问

## 类加载器

- "通过一个类的全限定名来获取描述该类的二进制字节流"实现这个动作的代码被称为"类加载器"(Class Loader)

### 类与类加载器

- 类加载器虽然只用于实现类的加载动作,但它在Java程序中起到的作用却远超类加载阶段
- 对于任意一个类,都必须由加载它的类加载器和这个类本身一起共同确立其在Java虚拟机中的唯一性,每一个类加载器,都拥有一个独立的类名称空间
    - 比较两个类是否相等,只有在这两个类是由同一个类加载器加载的前提下才有意义,否则,即使这两个类来源于同一个Class文件,被同一个Java虚拟机加载,只要加载它们的类加载器不同,那这两个类就必定不相等
    - 相等,包括代表类的Class对象的equals()方法,isAssignableFrom()方法,isInstance()方法的返回结果,也包括了使用instanceof关键字做对象所属关系判定等各种情况

- 业务代码
    - com.weiliai.chapter7.ClassLoaderTest

### 双亲委派模型

- 在Java虚拟机的角度来看,只存在两种不同的类加载器
    - 一种是启动类加载器(Bootstrap ClassLoader),基于C++实现是虚拟机的一部分
    - 另外一种就是其他所有的类加载器,这些类加载器都由Java语言实现,独立存在于虚拟机外部,并且全都继承自抽象类java.lang.ClassLoader

- 在Java开发人员的角度看,Java一直保持着三层类加载器,双亲委派的类加载架构
- 系统提供的三个类加载器
    - 启动类加载器(Bootstrap Class Loader)
        - 负责加载存放在<JAVA_HOME>\lib目录,或者-Xbootclasspath参数所指定的路径中存放的,可以通过sun.boot.class.path系统变量查看
        - Java虚拟机能够识别的(按照文件名识别,如rt.jar,tools.jar,名字不符合的类库即使放在lib目录中也不会被加载)
        - 启动类加载器无法被Java程序直接引用,用户在编写自定义类加载器时,如果需要把加载请求委派给引导类加载器去处理,那直接使用null即可,null值来代表引导类加载器的约定规则
    - 扩展类加载器(Extension Class Loader)
        - 在类sun.misc.Launcher$ExtClassLoader中以Java代码的形式实现的
        - 负责加载<JAVA_HOME>\lib\ext目录中,或者被java.ext.dirs系统变量所指定的路径中所有的类库
        - 扩展类加载器是由Java代码实现的,开发者可以直接在程序中使用扩展类加载器来加载Class文件
        - JDK的开发团队允许用户将具有通用性的类库放置在ext目录里以扩展Java SE的功能
    - 应用程序类加载器(Application Class Loader)
        - 由sun.misc.Launcher$AppClassLoader来实现
        - 于应用程序类加载器是ClassLoader类中的getSystemClassLoader()方法的返回值,因此也被称为系统类加载器
        - 负责加载用户类路径（ClassPath）上所有的类库,开发者同样可以直接在代码中使用这个类加载器
        - 如果应用程序中没有自定义过自己的类加载器,一般情况下这个就是程序中默认的类加载器

- 双亲委派模型
    - 双亲委派模型要求除了顶层的启动类加载器外,其余的类加载器都应有自己的父类加载器
    - 类加载器之间的父子关系一般不是以继承(Inheritance)的关系来实现的，而是通常使用组合(Composition)关系来复用父加载器的代码
    - 它并不是一个具有强制性约束力的模型,而是Java设计者们推荐给开发者的类加载器实现的最佳实践

- 双亲委派模型的工作过程
    - 如果一个类加载器收到了类加载的请求,它首先不会自己去尝试加载这个类,而是把这个请求委派给父类加载器去完成,每一个层次的类加载器都是如此,因此所有的加载请求最终都应该传送到最顶层的启动类加载器中
    - 只有当父加载器反馈自己无法完成这个加载请求(它的搜索范围中没有找到所需的类)时,子加载器才会尝试自己去完成加载

### 破坏双亲委派模型

- 第一次破坏
    - ClassLoader在1.2之前已经存在,所以loadClass()方法也已经存在
    - 在1.2的时候要引入双亲委派模型,为了向前兼容,loadClass()方法还得保留着使之得以重写,新搞了个findClass()方法让用户去重写,并呼吁大家不要重写loadClass只要重写findClass
- 第二次破坏
    - JNDI,JDBC之类的情况,比如JDBC的实现类是用户定义的classpath,只能由应用类加载器去加载,启动类加载器只能委托子类来加载数据库厂商们提供的具体实现,这就违反了自下而上的委托机制
    - 因此搞了个线程上下文类加载器,通过setContextClassLoader()默认就是应用类加载器,然后利用Thread.current.currentThread().getContextClassLoader()
      获取类加载器加载
- 第三次破坏
    - 由于用户对程序动态性的追求而导致的,可以理解为热部署
- 第四次破坏
    - JDK9推出的模块化

## Java模块化系统

- 在JDK 9中引入的Java模块化系统(Java Platform Module System,JPMS)
  是Java的一次重要升级,为了能够实现模块化的关键目标-可配置的封装隔离机制,Java虚拟机堆类加载器架构也做出了响应的变动调整,才使模块化系统得以顺利运作

### 模块的兼容性

### 模块化下的类加载器




