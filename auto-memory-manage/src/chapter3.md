# 垃圾收集器与内存分配策略

## 概述

- 垃圾收集
    - 哪些内存需要回收
    - 什么时候回收
    - 如何回收

## 对象存活判定

- 不可能再被任何途径使用的对象,认定为垃圾对象

### 引用计数算法

- 引用技术算法(Reference Counting):为了保证正确性,需要配合大量额外处理(例如:解决循环引用的问题)

- 算法思路:
    - 在对象中添加一个引用计数器,每当有一个地方引用它时,计数器就加一;
    - 引用失效就减一;
    - 任何时刻计数器为零就是不在使用

### 可达性分析算法

- 可达性分析算法(Reachability Analysis):通过一系列称为GC Roots的根对象作为起始节点集,从这些节点,根据引用关系向下搜索,搜索过程所走的路径称为引用链(Reference Chain),如果某个对象到GC
  Roots间没有任何引用链相连,则证明此对象不可能在被使用,认定为垃圾对象

- Java中的固定的GC Roots对象
    - 虚拟机栈(栈帧中的本地变量表)中引用的对象,譬如各线程被调用的方法堆栈中使用到的参数,局部变量,临时变量等
    - 在本地方法栈中JNI(Native方法)引用的对象
    - 方法区中常量引用的对象,譬如字符串常量池(String Table)里的引用
    - 所有被同步锁(Synchronized关键字)持有的对象
    - 反映Java虚拟机内部情况的JMXBean,JVMTI中注册的回调,本地代码缓存等

- Java中的引用
    - 强引用(Strongly Reference)
        - 指在程序代码之中普遍存在的引用赋值,类似Object obj=new Object()
        - 无论任何情况下,只要强引用关系存在,垃圾回收器就不会回收掉被引用的对象
    - 软引用(Soft Reference)
        - 描述一些有用但非必须的对象
        - 只被软引用关联着的对象,在系统将要发生OOM之前,会把这些对象列进回收范围之中进行第二次回收,如果这次回收还是不够,就会抛出OOM
    - 弱引用(Weak Reference)
        - 描述非必须对象,比软引用更弱一些,只能生存到下一次垃圾收集发生为止
        - 当垃圾收集器开始工作时,无论内存是否足够,都会被回收掉
    - 虚引用(Phantom Reference)
        - 称为幽灵引用或幻影引用,最弱的一种引用关系
        - 对象是否有虚引用的存在,完全不会对其生存时间构成影响,也无法通过虚引用来获取一个对象实例
        - 为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知

### finalize方法

- 即使在可达性分析算法中判定为不可达的对象,也不是非死不可,暂时处于缓刑,要真正宣告一个对象死亡,至少经历两次标记过程
    - 如果在进行可达性分析时发现没有和GC Roots相连的引用链,那么它将会被第一次标记
    - 随后进行筛选,筛选此对象是否需要执行finalize()方法
        - 假如没有覆写这个方法或者已经被调用过一次,这两种情况都被视为没必要执行
        - 如果覆写且未执行过,则对象被放置到一个FQueue的队列,使用一个Finalizer线程去执行,注:这里执行代表运行,但不一定会等待运行结束
        - 针对FQueue中对象进行第二次标记

- finalize方法是对象逃脱死亡命运的最后一次机会,如果想拯救自己-只要重新与引用链上的任何一个对象关联即可,譬如把自己(this关键字)赋值给某个类变量或对象成员变量
- finalize方法只会被虚拟机调用一次,完全不推荐覆写这个方法,完全可以忘记这个方法

### 回收方法区

- 方法区的垃圾收集主要回收两部分内容
    - 废弃的常量
        - 已经没有任何字符串对象引用常量池中的该常量
        - 虚拟机中也没有其他地方引用这个字面量
    - 不再使用的类型
        - 该类所有的实例都已经被回收,即Java堆中不存在该类及其任何派生子类的实例
        - 加载该类的类加载器已经被回收(通常很难达成)
        - 该类的java.lang.Class对象没有在任何地方被引用,无法在任何地方通过反射访问该类的方法

- 在大量使用反射,动态代理,CGLib等字节码框架,动态生成JSP以及OSGi这类频繁自定义类加载器的场景中,通常都需要Java虚拟机具备类型卸载的能力,以保证不会对方法区造成过大的内存压力

## 垃圾收集算法

- 垃圾收集算法
    - 引用计数式垃圾收集(Reference Counting GC):直接垃圾收集
    - 追踪式垃圾收集(Tracing GC):间接垃圾收集,本章只涉及此种

### 分代收集理论

- 分代收集(Generational Collection)
    - 弱分代假说(Weak Generational Hypothesis):绝大多数对象都是朝生夕灭
    - 强分代假说(Strong Generational Hypothesis):熬过越多次垃圾收集过程的对象就越难消亡
    - 跨代引用假说(Intergenerational Reference Hypothesis):跨代引用相对于同代引用来说是极少数
        - 在新生代上建立一个全局的数据结构(称为记忆集,Remembered Set),这个结构把老年代划分成若干小块,标识出老年代的哪一块内存存在跨代引用

- 收集分类
    - 部分收集(Partial GC):指目标不是完整收集整个Java堆里的垃圾收集
        - 新生代收集(Minor GC/Young GC):指目标只是新生代的垃圾收集
        - 老年代收集(Major GC/Old GC):指目标只是老年代的垃圾收集
        - 混合收集(Mixed GC):指目标是收集整个新生代以及部分老年代的垃圾收集,目前只有G1收集器会有这种行为
    - 整堆收集(Full GC):收集整个Java堆和方法区垃圾收集

### 标记-清除算法

- 标记-清除算法
    - 标记阶段:首先标记出所有需要回收的对象(或不回收的对象)
    - 清除阶段:标记完成后,统一回收掉所有被标记的对象(或未标记的对象)

- 存在的缺点
    - 执行效率不稳定,如果Java堆中包含大量对象,其中大部分需要回收,导致执行效率随对象增长降低
    - 内存空间碎片化

### 标记-复制算法

- 标记-复制算法(复制算法):解决大量可回收对象的时的执行效率低的问题
    - 将内存划分为大小相等,每次只使用其中一块,当一块用完以后,就把存活的复制到另一块上去,然后把已使用的内存一次性清理
    - 如果存活对象太多,将会产生大量内存复制的开销并且浪费内存

### 标记-整理算法

- 标记-整理算法:其中的标记过程仍然与标记-清除算法一样,但后续步骤不是直接对可回收对象进行清理,而是让所有存活的对象都向内存空间一端移动,然后直接清理掉边界以外的内存.
    - 标记-清除算法与标记-整理算法的本质差异在于前者是一种非移动式的回收算法,后者时移动式
    - 是否移动回收存活对象是一项优缺点并存的风险抉择
        - 如果移动存活对象,尤其是在老年代这种每次回收都有大量对象存活区域,移动存活对象并更新所有引用这些对象的地方将会是一种极为负重的操作
        - 这种对象移动必须全程暂停用户程序才能进行,被称为stop the world

## HotSpot的算法细节实现

## 经典垃圾收集器

- 经典垃圾收集器
    - young generation
        - Serial
        - ParNew
        - ParallelScavenge
    - Tenured generation
        - CMS
        - Serial Old(MSC)
        - Parallel Old
    - 不分代
        - G1

### Serial收集器

- Serial收集器是最基础,历史最悠久的收集器,年轻代
    - 串行,单线程,stop the world
    - 新生代采用复制算法,暂停所有用户线程;老年代采用标记-整理算法暂停所有用户线程

- Serial收集器搭配
    - CMS
    - SerialOld(MSC)

### ParNew收集器

- ParNew收集器实质是Serial收集器的多线程并行版本,年轻代
    - 并行,多线程,stop the world
    - 新生代采用复制算法,暂停所有用户线程;老年代采用标记-整理算法暂停所有用户线程

- ParNew收集器搭配
    - CMS
    - SerialOld(MSC)

### Parallel Scavenge收集器

- Parallel Scavenge收集器也是一款新生代收集器,与ParNew类似,但吞吐量可控
    - 并行,多线程,stop the world,可控吞吐量
    - 吞吐量=运行用户代码时间/(运行用户代码时间+运行垃圾收集时间)
        - 控制最大垃圾收集停顿时间 -XX:MaxGCPauseMillis,允许大于0的毫秒值,收集器将尽力保证内存回收花费的时间不超过用户设定值
            - 垃圾收集停顿时间缩短是以牺牲吞吐量和新生代空间为代价换取的,过小导致垃圾回收频繁
        - 吞吐量大小 -XX:GCTimeRatio,是一个大于0小于100的整数,就是垃圾收集时间占总时间的比率,吞吐量的倒数,默认值99,即允许最大1%(1/(1+99))

- Parallel Scavenge收集器搭配
    - ParallelOld
    - SerialOld(MSC)

### Serial Old收集器

- Serial Old是Serial收集器的老年代版本
    - 串行,单线程,stop the world
    - 一种是在JDK5以及之前的版本中与Parallel Scavenge收集器搭配使用,另外一种就是作为CMS收集器发生失败时的后备预案,在并发收集发生Concurrent Mode Failure时使用

### Parallel Old收集器

- Parallel Old收集器是Parallel Scavenge收集器的老年代版本,支持多线程并发收集

### CMS收集器

- CMS收集器是一种以获取最短回收停顿时间为目标的收集器
- CMS收集器过程
    - 初始标记(initial mark)
    - 并发标记(concurrent mark)
    - 重新标记(remark)
    - 并发清楚(concurrent sweep)
- 初始标记,重新标记这两个步骤仍然需要stop the world
    - 初始标记仅仅只是标记一下GC Roots能直接关联到的对象,速度很快
    - 并发标记阶段就是从GC Roots的直接关联对象开始遍历整个对象图的过程,这个过程耗时较长但是不需要停顿用户线程,可以与垃圾收集线程一起并发运行
    - 重新标记阶段则是为了修正并发标记期间,因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录,这个阶段的停顿时间通常会比初始标记阶段稍长一些,但也远比并发标记阶段的时间短
    - 并发清除阶段,清理删除掉标记阶段判断的已经死亡的对象,由于不需要移动存活对象,所以这个阶段也是可以与用户线程同时并发

### Garbage First收集器

- G1是一款主要面向服务端应用的垃圾收集器

### Shenandoah收集器

## 实战:内存分配与回收策略

- Java技术体系的自动内存管理,最根本的目标是自动化地解决两个问题
    - 自动给对象分配内存
    - 自动回收分配给对象的内存

### 对象优先在Eden分配

- 多数情况下,对象在新生代Eden区中分配,当Eden区没有足够空间进行分配时,虚拟机会发起一次Minor GC
    - -XX:+PrintGCDetails,打印收集器日志参数